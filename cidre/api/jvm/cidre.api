public abstract class at/asitplus/cidre/IpAddress : java/lang/Comparable {
	public static final field Companion Lat/asitplus/cidre/IpAddress$Companion;
	public synthetic fun <init> ([BLat/asitplus/cidre/IpAddress$Specification;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun compareTo (Lat/asitplus/cidre/IpAddress;)I
	public synthetic fun compareTo (Ljava/lang/Object;)I
	public final fun copy ()Lat/asitplus/cidre/IpAddress;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getFamily ()Lat/asitplus/cidre/IpAddress$Family;
	public final fun getOctets ()[B
	public abstract fun getSegments ()Ljava/util/List;
	public fun hashCode ()I
	public final fun isSpecified ()Z
	public final fun mask ([B)I
	public final fun mask-WZ4Q5Ns (I)I
}

public final class at/asitplus/cidre/IpAddress$Companion {
	public final fun invoke (Ljava/lang/String;)Lat/asitplus/cidre/IpAddress;
	public final fun invoke ([B)Lat/asitplus/cidre/IpAddress;
}

public final class at/asitplus/cidre/IpAddress$Family : java/lang/Enum {
	public static final field V4 Lat/asitplus/cidre/IpAddress$Family;
	public static final field V6 Lat/asitplus/cidre/IpAddress$Family;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public final fun getNumberOfBits ()I
	public final fun getNumberOfOctets ()I
	public static fun valueOf (Ljava/lang/String;)Lat/asitplus/cidre/IpAddress$Family;
	public static fun values ()[Lat/asitplus/cidre/IpAddress$Family;
}

public abstract interface class at/asitplus/cidre/IpAddress$Specification {
	public abstract fun getFamily ()Lat/asitplus/cidre/IpAddress$Family;
	public abstract fun getNumberOfOctets ()I
	public abstract fun getRegex ()Lat/asitplus/cidre/IpAddress$Specification$RegexSpec;
	public abstract fun getSegmentSeparator ()C
}

public abstract class at/asitplus/cidre/IpAddress$Specification$RegexSpec {
	public fun <init> ()V
	public abstract fun getAddress ()Lkotlin/text/Regex;
	public abstract fun getSegment ()Lkotlin/text/Regex;
}

public final class at/asitplus/cidre/IpAddress$V4 : at/asitplus/cidre/IpAddress {
	public static final field Companion Lat/asitplus/cidre/IpAddress$V4$Companion;
	public fun <init> ([B)V
	public final fun getAddressClass ()Lat/asitplus/cidre/IpAddress$V4$Class;
	public fun getSegments ()Ljava/util/List;
	public fun toString ()Ljava/lang/String;
}

public final class at/asitplus/cidre/IpAddress$V4$Class : java/lang/Enum {
	public static final field A Lat/asitplus/cidre/IpAddress$V4$Class;
	public static final field B Lat/asitplus/cidre/IpAddress$V4$Class;
	public static final field C Lat/asitplus/cidre/IpAddress$V4$Class;
	public static final field D Lat/asitplus/cidre/IpAddress$V4$Class;
	public static final field E Lat/asitplus/cidre/IpAddress$V4$Class;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public static fun valueOf (Ljava/lang/String;)Lat/asitplus/cidre/IpAddress$V4$Class;
	public static fun values ()[Lat/asitplus/cidre/IpAddress$V4$Class;
}

public final class at/asitplus/cidre/IpAddress$V4$Companion : at/asitplus/cidre/IpAddress$Specification {
	public fun getFamily ()Lat/asitplus/cidre/IpAddress$Family;
	public fun getNumberOfOctets ()I
	public fun getRegex ()Lat/asitplus/cidre/IpAddress$Specification$RegexSpec;
	public fun getSegmentSeparator ()C
	public final fun invoke (Ljava/lang/String;)Lat/asitplus/cidre/IpAddress$V4;
}

public final class at/asitplus/cidre/IpAddress$V6 : at/asitplus/cidre/IpAddress {
	public static final field Companion Lat/asitplus/cidre/IpAddress$V6$Companion;
	public fun <init> ([B)V
	public final fun getEmbeddedIpV4Address ()Lat/asitplus/cidre/IpAddress$V4;
	public fun getSegments ()Ljava/util/List;
	public final fun isIpv4Compatible ()Z
	public final fun isIpv4Mapped ()Z
	public fun toString ()Ljava/lang/String;
	public final fun toString (Z)Ljava/lang/String;
}

public final class at/asitplus/cidre/IpAddress$V6$Companion : at/asitplus/cidre/IpAddress$Specification {
	public fun getFamily ()Lat/asitplus/cidre/IpAddress$Family;
	public fun getNumberOfOctets ()I
	public final fun getPREFIX_IPV4_COMPAT ()[B
	public final fun getPREFIX_IPV4_MAPPED ()[B
	public fun getRegex ()Lat/asitplus/cidre/IpAddress$Specification$RegexSpec;
	public fun getSegmentSeparator ()C
	public final fun invoke (Ljava/lang/String;)Lat/asitplus/cidre/IpAddress$V6;
}

public abstract interface class at/asitplus/cidre/IpAddressAndPrefix {
	public abstract fun getAddress ()Lat/asitplus/cidre/IpAddress;
	public fun getFamily ()Lat/asitplus/cidre/IpAddress$Family;
	public fun getHostMask ()[B
	public fun getHostPart ()[B
	public abstract fun getNetmask ()[B
	public fun getNetworkPart ()[B
	public fun getNumberOfHostBits-pVg5ArA ()I
	public abstract fun getPrefix-pVg5ArA ()I
	public abstract fun isLinkLocal ()Z
	public abstract fun isLoopback ()Z
	public abstract fun isMulticast ()Z
}

public final class at/asitplus/cidre/IpAddressAndPrefix$DefaultImpls {
	public static fun getFamily (Lat/asitplus/cidre/IpAddressAndPrefix;)Lat/asitplus/cidre/IpAddress$Family;
	public static fun getHostMask (Lat/asitplus/cidre/IpAddressAndPrefix;)[B
	public static fun getHostPart (Lat/asitplus/cidre/IpAddressAndPrefix;)[B
	public static fun getNetworkPart (Lat/asitplus/cidre/IpAddressAndPrefix;)[B
	public static fun getNumberOfHostBits-pVg5ArA (Lat/asitplus/cidre/IpAddressAndPrefix;)I
}

public abstract interface class at/asitplus/cidre/IpAddressAndPrefix$V4 : at/asitplus/cidre/IpAddressAndPrefix {
	public abstract fun getAddress ()Lat/asitplus/cidre/IpAddress$V4;
	public abstract fun isPrivate ()Z
	public abstract fun isPublic ()Z
	public fun netmaskToString ()Ljava/lang/String;
	public fun toString (Z)Ljava/lang/String;
}

public final class at/asitplus/cidre/IpAddressAndPrefix$V4$DefaultImpls {
	public static fun getFamily (Lat/asitplus/cidre/IpAddressAndPrefix$V4;)Lat/asitplus/cidre/IpAddress$Family;
	public static fun getHostMask (Lat/asitplus/cidre/IpAddressAndPrefix$V4;)[B
	public static fun getHostPart (Lat/asitplus/cidre/IpAddressAndPrefix$V4;)[B
	public static fun getNetworkPart (Lat/asitplus/cidre/IpAddressAndPrefix$V4;)[B
	public static fun getNumberOfHostBits-pVg5ArA (Lat/asitplus/cidre/IpAddressAndPrefix$V4;)I
	public static fun netmaskToString (Lat/asitplus/cidre/IpAddressAndPrefix$V4;)Ljava/lang/String;
	public static fun toString (Lat/asitplus/cidre/IpAddressAndPrefix$V4;Z)Ljava/lang/String;
}

public abstract interface class at/asitplus/cidre/IpAddressAndPrefix$V6 : at/asitplus/cidre/IpAddressAndPrefix {
	public abstract fun getAddress ()Lat/asitplus/cidre/IpAddress$V6;
	public abstract fun isDiscardOnly ()Z
	public abstract fun isDocumentation ()Z
	public abstract fun isGlobalUnicast ()Z
	public abstract fun isIpV4Compatible ()Z
	public abstract fun isIpV4Mapped ()Z
	public abstract fun isReserved ()Z
	public abstract fun isUniqueLocal ()Z
	public abstract fun isUniqueLocalLocallyAssigned ()Z
	public fun toString (Z)Ljava/lang/String;
}

public final class at/asitplus/cidre/IpAddressAndPrefix$V6$DefaultImpls {
	public static fun getFamily (Lat/asitplus/cidre/IpAddressAndPrefix$V6;)Lat/asitplus/cidre/IpAddress$Family;
	public static fun getHostMask (Lat/asitplus/cidre/IpAddressAndPrefix$V6;)[B
	public static fun getHostPart (Lat/asitplus/cidre/IpAddressAndPrefix$V6;)[B
	public static fun getNetworkPart (Lat/asitplus/cidre/IpAddressAndPrefix$V6;)[B
	public static fun getNumberOfHostBits-pVg5ArA (Lat/asitplus/cidre/IpAddressAndPrefix$V6;)I
	public static fun toString (Lat/asitplus/cidre/IpAddressAndPrefix$V6;Z)Ljava/lang/String;
}

public abstract class at/asitplus/cidre/IpInterface : at/asitplus/cidre/IpAddressAndPrefix {
	public static final field Companion Lat/asitplus/cidre/IpInterface$Companion;
	public synthetic fun <init> (ILat/asitplus/cidre/IpNetwork;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun getAddress ()Lat/asitplus/cidre/IpAddress;
	public fun getFamily ()Lat/asitplus/cidre/IpAddress$Family;
	public fun getHostMask ()[B
	public fun getHostPart ()[B
	public fun getNetmask ()[B
	public final fun getNetwork ()Lat/asitplus/cidre/IpNetwork;
	public fun getNetworkPart ()[B
	public fun getNumberOfHostBits-pVg5ArA ()I
	public fun getPrefix-pVg5ArA ()I
	public fun isLinkLocal ()Z
	public fun isLoopback ()Z
	public fun isMulticast ()Z
	public fun toString ()Ljava/lang/String;
}

public final class at/asitplus/cidre/IpInterface$Companion {
	public final fun invoke (Ljava/lang/String;)Lat/asitplus/cidre/IpInterface;
	public final fun invoke-Qn1smSk (Lat/asitplus/cidre/IpAddress;I)Lat/asitplus/cidre/IpInterface;
}

public final class at/asitplus/cidre/IpInterface$V4 : at/asitplus/cidre/IpInterface {
	public static final field Companion Lat/asitplus/cidre/IpInterface$V4$Companion;
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress$V4;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun getAddress ()Lat/asitplus/cidre/IpAddress$V4;
	public synthetic fun getAddress ()Lat/asitplus/cidre/IpAddress;
}

public final class at/asitplus/cidre/IpInterface$V4$Companion {
	public final fun invoke (Ljava/lang/String;)Lat/asitplus/cidre/IpInterface$V4;
}

public final class at/asitplus/cidre/IpInterface$V6 : at/asitplus/cidre/IpInterface {
	public static final field Companion Lat/asitplus/cidre/IpInterface$V6$Companion;
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress$V6;ILat/asitplus/cidre/IpNetwork$V6;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress$V6;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun getAddress ()Lat/asitplus/cidre/IpAddress$V6;
	public synthetic fun getAddress ()Lat/asitplus/cidre/IpAddress;
}

public final class at/asitplus/cidre/IpInterface$V6$Companion {
	public final fun invoke (Ljava/lang/String;)Lat/asitplus/cidre/IpInterface$V6;
}

public abstract class at/asitplus/cidre/IpNetwork : at/asitplus/cidre/IpAddressAndPrefix, java/lang/Comparable {
	public static final field Companion Lat/asitplus/cidre/IpNetwork$Companion;
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress;IZZLkotlin/jvm/internal/DefaultConstructorMarker;)V
	protected abstract fun addressSpaceUntil (I)Lkotlin/sequences/Sequence;
	public fun compareTo (Lat/asitplus/cidre/IpNetwork;)I
	public synthetic fun compareTo (Ljava/lang/Object;)I
	public final fun contains (Lat/asitplus/cidre/IpAddress;)Z
	public final fun contains (Lat/asitplus/cidre/IpInterface;)Z
	public final fun contains (Lat/asitplus/cidre/IpNetwork;)Z
	public fun equals (Ljava/lang/Object;)Z
	public final fun getAddressSpace ()Lkotlin/sequences/Sequence;
	public final fun getAssignableHostRange ()Lkotlin/sequences/Sequence;
	public fun getFamily ()Lat/asitplus/cidre/IpAddress$Family;
	public final fun getFirstAssignableHost ()Lat/asitplus/cidre/IpInterface;
	public fun getHostMask ()[B
	public fun getHostPart ()[B
	public final fun getLastAddress ()Lat/asitplus/cidre/IpAddress;
	public final fun getLastAssignableHost ()Lat/asitplus/cidre/IpInterface;
	protected final fun getLastOctetInBlock ()[B
	public fun getNetmask ()[B
	public fun getNetworkPart ()[B
	public fun getNumberOfHostBits-pVg5ArA ()I
	public fun getPrefix-pVg5ArA ()I
	public abstract fun getSize ()Ljava/lang/Object;
	public final fun getSpecialRanges ()Lat/asitplus/cidre/IpNetwork$SpecialRanges;
	public fun hashCode ()I
	public final fun interfaceFor (Lat/asitplus/cidre/IpAddress;)Lat/asitplus/cidre/IpInterface;
	public final fun isAdjacentTo (Lat/asitplus/cidre/IpNetwork;)Z
	public fun isLinkLocal ()Z
	public fun isLoopback ()Z
	public fun isMulticast ()Z
	public final fun isSubnetOf (Lat/asitplus/cidre/IpNetwork;)Z
	public final fun isSupernetOf (Lat/asitplus/cidre/IpNetwork;)Z
	public final fun overlaps (Lat/asitplus/cidre/IpNetwork;)Z
	public abstract fun plus (Lat/asitplus/cidre/IpAddress;)Lat/asitplus/cidre/IpAddress;
	public final fun subnet-WZ4Q5Ns (I)Lkotlin/sequences/Sequence;
	public final fun subnetRelative-WZ4Q5Ns (I)Lkotlin/sequences/Sequence;
	public fun toString ()Ljava/lang/String;
}

public final class at/asitplus/cidre/IpNetwork$Companion {
	public final fun forAddress-Qn1smSk (Lat/asitplus/cidre/IpAddress;I)Lat/asitplus/cidre/IpNetwork;
	public final fun invoke (Ljava/lang/String;Z)Lat/asitplus/cidre/IpNetwork;
	public static synthetic fun invoke$default (Lat/asitplus/cidre/IpNetwork$Companion;Ljava/lang/String;ZILjava/lang/Object;)Lat/asitplus/cidre/IpNetwork;
	public final fun invoke-OsBMiQA (Lat/asitplus/cidre/IpAddress;IZ)Lat/asitplus/cidre/IpNetwork;
	public static synthetic fun invoke-OsBMiQA$default (Lat/asitplus/cidre/IpNetwork$Companion;Lat/asitplus/cidre/IpAddress;IZILjava/lang/Object;)Lat/asitplus/cidre/IpNetwork;
}

public abstract interface class at/asitplus/cidre/IpNetwork$SpecialRanges {
	public abstract fun getLinkLocal ()Lat/asitplus/cidre/IpNetwork;
	public abstract fun getLoopback ()Lat/asitplus/cidre/IpNetwork;
	public abstract fun getMulticast ()Lat/asitplus/cidre/IpNetwork;
}

public abstract interface class at/asitplus/cidre/IpNetwork$Specification {
	public abstract fun getSpecialRanges ()Lat/asitplus/cidre/IpNetwork$SpecialRanges;
}

public final class at/asitplus/cidre/IpNetwork$V4 : at/asitplus/cidre/IpNetwork, at/asitplus/cidre/IpAddressAndPrefix$V4 {
	public static final field Companion Lat/asitplus/cidre/IpNetwork$V4$Companion;
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress$V4;IZILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress$V4;IZLkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun getAddress ()Lat/asitplus/cidre/IpAddress$V4;
	public synthetic fun getAddress ()Lat/asitplus/cidre/IpAddress;
	public final fun getBroadcastAddress ()Lat/asitplus/cidre/IpInterface$V4;
	public synthetic fun getSize ()Ljava/lang/Object;
	public fun getSize-s-VKNKU ()J
	public fun isPrivate ()Z
	public fun isPublic ()Z
	public fun netmaskToString ()Ljava/lang/String;
	public fun plus (Lat/asitplus/cidre/IpAddress;)Lat/asitplus/cidre/IpAddress$V4;
	public synthetic fun plus (Lat/asitplus/cidre/IpAddress;)Lat/asitplus/cidre/IpAddress;
	public fun toString (Z)Ljava/lang/String;
}

public final class at/asitplus/cidre/IpNetwork$V4$Companion : at/asitplus/cidre/IpNetwork$Specification {
	public final fun forAddress-Qn1smSk (Lat/asitplus/cidre/IpAddress$V4;I)Lat/asitplus/cidre/IpNetwork$V4;
	public fun getSpecialRanges ()Lat/asitplus/cidre/IpNetwork$SpecialRanges;
	public final fun invoke (Ljava/lang/String;Z)Lat/asitplus/cidre/IpNetwork$V4;
	public static synthetic fun invoke$default (Lat/asitplus/cidre/IpNetwork$V4$Companion;Ljava/lang/String;ZILjava/lang/Object;)Lat/asitplus/cidre/IpNetwork$V4;
}

public final class at/asitplus/cidre/IpNetwork$V4$SpecialRanges : at/asitplus/cidre/IpNetwork$SpecialRanges {
	public static final field INSTANCE Lat/asitplus/cidre/IpNetwork$V4$SpecialRanges;
	public fun getLinkLocal ()Lat/asitplus/cidre/IpNetwork$V4;
	public synthetic fun getLinkLocal ()Lat/asitplus/cidre/IpNetwork;
	public fun getLoopback ()Lat/asitplus/cidre/IpNetwork$V4;
	public synthetic fun getLoopback ()Lat/asitplus/cidre/IpNetwork;
	public fun getMulticast ()Lat/asitplus/cidre/IpNetwork$V4;
	public synthetic fun getMulticast ()Lat/asitplus/cidre/IpNetwork;
	public final fun getPrivate ()Ljava/util/List;
}

public final class at/asitplus/cidre/IpNetwork$V6 : at/asitplus/cidre/IpNetwork, at/asitplus/cidre/IpAddressAndPrefix$V6 {
	public static final field Companion Lat/asitplus/cidre/IpNetwork$V6$Companion;
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress$V6;IZILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public synthetic fun <init> (Lat/asitplus/cidre/IpAddress$V6;IZLkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun getAddress ()Lat/asitplus/cidre/IpAddress$V6;
	public synthetic fun getAddress ()Lat/asitplus/cidre/IpAddress;
	public fun getSize ()Lat/asitplus/cidre/byteops/Overlong;
	public synthetic fun getSize ()Ljava/lang/Object;
	public fun isDiscardOnly ()Z
	public fun isDocumentation ()Z
	public fun isGlobalUnicast ()Z
	public fun isIpV4Compatible ()Z
	public fun isIpV4Mapped ()Z
	public fun isReserved ()Z
	public fun isUniqueLocal ()Z
	public fun isUniqueLocalLocallyAssigned ()Z
	public fun plus (Lat/asitplus/cidre/IpAddress;)Lat/asitplus/cidre/IpAddress$V6;
	public synthetic fun plus (Lat/asitplus/cidre/IpAddress;)Lat/asitplus/cidre/IpAddress;
	public fun toString (Z)Ljava/lang/String;
}

public final class at/asitplus/cidre/IpNetwork$V6$Companion : at/asitplus/cidre/IpNetwork$Specification {
	public final fun forAddress-Qn1smSk (Lat/asitplus/cidre/IpAddress$V6;I)Lat/asitplus/cidre/IpNetwork$V6;
	public fun getSpecialRanges ()Lat/asitplus/cidre/IpNetwork$SpecialRanges;
	public final fun invoke (Ljava/lang/String;Z)Lat/asitplus/cidre/IpNetwork$V6;
	public static synthetic fun invoke$default (Lat/asitplus/cidre/IpNetwork$V6$Companion;Ljava/lang/String;ZILjava/lang/Object;)Lat/asitplus/cidre/IpNetwork$V6;
}

public final class at/asitplus/cidre/IpNetwork$V6$SpecialRanges : at/asitplus/cidre/IpNetwork$SpecialRanges {
	public static final field INSTANCE Lat/asitplus/cidre/IpNetwork$V6$SpecialRanges;
	public final fun getDiscardOnly ()Lat/asitplus/cidre/IpNetwork$V6;
	public final fun getDocumentation ()Lat/asitplus/cidre/IpNetwork$V6;
	public final fun getGlobalUnicast ()Lat/asitplus/cidre/IpNetwork$V6;
	public final fun getIpV4Compatible ()Lat/asitplus/cidre/IpNetwork$V6;
	public final fun getIpV4Mapped ()Lat/asitplus/cidre/IpNetwork$V6;
	public fun getLinkLocal ()Lat/asitplus/cidre/IpNetwork$V6;
	public synthetic fun getLinkLocal ()Lat/asitplus/cidre/IpNetwork;
	public fun getLoopback ()Lat/asitplus/cidre/IpNetwork$V6;
	public synthetic fun getLoopback ()Lat/asitplus/cidre/IpNetwork;
	public fun getMulticast ()Lat/asitplus/cidre/IpNetwork$V6;
	public synthetic fun getMulticast ()Lat/asitplus/cidre/IpNetwork;
	public final fun getReserved ()Ljava/util/List;
	public final fun getUniqueLocal ()Lat/asitplus/cidre/IpNetwork$V6;
	public final fun getUniqueLocalLocallyAssigned ()Lat/asitplus/cidre/IpNetwork$V6;
}

public final class at/asitplus/cidre/JvmInteropKt {
	public static final fun invoke (Lat/asitplus/cidre/IpAddress$Companion;Ljava/net/InetAddress;)Lat/asitplus/cidre/IpAddress;
	public static final fun invoke (Lat/asitplus/cidre/IpAddress$V4$Companion;Ljava/net/Inet4Address;)Lat/asitplus/cidre/IpAddress$V4;
	public static final fun invoke (Lat/asitplus/cidre/IpAddress$V6$Companion;Ljava/net/Inet6Address;)Lat/asitplus/cidre/IpAddress$V6;
	public static final fun toInetAddress (Lat/asitplus/cidre/IpAddress$V4;)Ljava/net/InetAddress;
	public static final fun toInetAddress (Lat/asitplus/cidre/IpAddress$V6;)Ljava/net/InetAddress;
	public static final fun toInetAddress (Lat/asitplus/cidre/IpAddress;)Ljava/net/InetAddress;
}

public final class at/asitplus/cidre/byteops/ByteOpsKt {
	public static final fun and ([B[B)[B
	public static final fun andInplace ([B[B)I
	public static final fun compareUnsignedBE ([B[B)I
	public static final fun inv ([B)[B
	public static final fun invInPlace ([B)V
	public static final fun invoke (Lkotlin/UInt$Companion;[BII)I
	public static final fun invoke (Lkotlin/ULong$Companion;[BII)J
	public static synthetic fun invoke$default (Lkotlin/UInt$Companion;[BIIILjava/lang/Object;)I
	public static synthetic fun invoke$default (Lkotlin/ULong$Companion;[BIIILjava/lang/Object;)J
	public static final fun minimalBeLength-VKZWuLQ (J)I
	public static final fun or ([B[B)[B
	public static final fun toByteArray-4PLdz1A (JI)[B
	public static synthetic fun toByteArray-4PLdz1A$default (JIILjava/lang/Object;)[B
	public static final fun toFourBytes-WZ4Q5Ns (I)[B
	public static final fun toNetmask-qim9Vi0 (II)[B
	public static final fun toNetmask-qim9Vi0 (ILat/asitplus/cidre/IpAddress$Family;)[B
	public static final fun toPrefix ([B)I
	public static final fun toShortArray ([BZ)[S
	public static synthetic fun toShortArray$default ([BZILjava/lang/Object;)[S
}

public final class at/asitplus/cidre/byteops/Overlong : java/lang/Comparable {
	public static final field Companion Lat/asitplus/cidre/byteops/Overlong$Companion;
	public synthetic fun <init> (JJZILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public synthetic fun <init> (JJZLkotlin/jvm/internal/DefaultConstructorMarker;)V
	public synthetic fun <init> (JLkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun and (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
	public final fun andInPlace (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
	public fun compareTo (Lat/asitplus/cidre/byteops/Overlong;)I
	public synthetic fun compareTo (Ljava/lang/Object;)I
	public final fun dec ()Lat/asitplus/cidre/byteops/Overlong;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getExtraBit ()Z
	public final fun getHi-s-VKNKU ()J
	public final fun getLo-s-VKNKU ()J
	public fun hashCode ()I
	public final fun inc ()Lat/asitplus/cidre/byteops/Overlong;
	public final fun inv ()Lat/asitplus/cidre/byteops/Overlong;
	public final fun invInPlace ()Lat/asitplus/cidre/byteops/Overlong;
	public final fun isZero ()Z
	public final fun minus (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
	public final fun minus-VKZWuLQ (J)Lat/asitplus/cidre/byteops/Overlong;
	public final fun minusAssign (Lat/asitplus/cidre/byteops/Overlong;)V
	public final fun minusAssign-VKZWuLQ (J)V
	public final fun or (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
	public final fun orInPlace (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
	public final fun plus (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
	public final fun plus-VKZWuLQ (J)Lat/asitplus/cidre/byteops/Overlong;
	public final fun plusAssign (Lat/asitplus/cidre/byteops/Overlong;)V
	public final fun plusAssign-VKZWuLQ (J)V
	public final fun shl (I)Lat/asitplus/cidre/byteops/Overlong;
	public final fun shr (I)Lat/asitplus/cidre/byteops/Overlong;
	public final fun toByteArray ()[B
	public fun toString ()Ljava/lang/String;
	public final fun xor (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
	public final fun xorInPlace (Lat/asitplus/cidre/byteops/Overlong;)Lat/asitplus/cidre/byteops/Overlong;
}

public final class at/asitplus/cidre/byteops/Overlong$Companion {
	public final fun getMAX_VALUE ()Lat/asitplus/cidre/byteops/Overlong;
	public final fun getONE ()Lat/asitplus/cidre/byteops/Overlong;
	public final fun getZERO ()Lat/asitplus/cidre/byteops/Overlong;
	public final fun invoke ([B)Lat/asitplus/cidre/byteops/Overlong;
}

